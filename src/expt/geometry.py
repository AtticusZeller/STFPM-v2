# Copyright (C) 2022-2025 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

import torch
from torch.nn import functional as F  # noqa: N812


def compute_layer_map(
    teacher_features: torch.Tensor,
    student_features: torch.Tensor,
    image_size: tuple[int, int] | torch.Size,
) -> torch.Tensor:
    """Compute anomaly map for a single feature layer.

    The layer map is computed by:
    1. Normalizing teacher and student features
    2. Computing L2 distance between normalized features
    3. Upscaling the distance map to original image size

    Args:
        teacher_features (torch.Tensor): Features from teacher network with
            shape `(B, C, H, W)`
        student_features (torch.Tensor): Features from student network with
            matching shape
        image_size (tuple[int, int] | torch.Size): Target size for upscaling
            in format `(H, W)`

    Returns:
        torch.Tensor: Anomaly scores for the layer, upscaled to
            `image_size`
    """
    norm_teacher_features = F.normalize(teacher_features)
    norm_student_features = F.normalize(student_features)

    layer_map = (
        0.5
        * torch.norm(
            norm_teacher_features - norm_student_features, p=2, dim=-3, keepdim=True
        )
        ** 2
    )
    return F.interpolate(
        layer_map, size=image_size, align_corners=False, mode="bilinear"
    )


def compute_anomaly_map(
    teacher_features: list[torch.Tensor],
    student_features: list[torch.Tensor],
    image_size: tuple[int, int] | torch.Size,
) -> torch.Tensor:
    """Compute overall anomaly map by combining multiple layer maps.

    The final anomaly map is based on Equation (4) in Section 3.3 and generated by:
    1. Computing per-layer anomaly maps via `compute_layer_map`
    2. Combining layer maps through element-wise multiplication

    Args:
        teacher_features (list[torch.Tensor]): Features from teacher network with
            shape `(B, C, H, W)`
        student_features (list[torch.Tensor]): Features from student network with
            matching shape
        image_size (tuple[int, int] | torch.Size): Target size for upscaling
            in format `(H, W)`

    Returns:
        torch.Tensor: Final anomaly map with shape `(B, 1, H, W)` where
            `B` is batch size and `(H, W)` matches `image_size`
    """
    batch_size = teacher_features[0].shape[0]
    device = teacher_features[0].device

    # Initialize anomaly map with ones
    anomaly_map = torch.ones(batch_size, 1, image_size[0], image_size[1], device=device)

    # Multiply layer maps
    for layer_t, layer_s in zip(teacher_features, student_features, strict=True):
        layer_map = compute_layer_map(layer_t, layer_s, image_size)
        anomaly_map *= layer_map

    return anomaly_map
